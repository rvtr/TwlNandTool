#include <nds.h>
#include <fat.h>
#include <stdio.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <nds/arm9/nand.h>
#include "f_xy.h"
#include "twltool/dsi.h"
#include "nandio.h"
#include "nandfirm.h"
#include "sector0.h"
#include "crypto.h"
#include "filesystem.h"
#include "../message.h"
#include "../main.h"
#include "../video.h"
#include "../menu.h"

// Master Boot Records
u8 mbrSamsung[68] = {
	0x00, 0x00, 0x00, 0x03, 0x18, 0x04, 0x06, 0x0F, 0xE0, 0x3B, 0x77, 0x08,
	0x00, 0x00, 0x89, 0x6F, 0x06, 0x00, 0x00, 0x02, 0xCE, 0x3C, 0x06, 0x0F,
	0xE0, 0xBE, 0x4D, 0x78, 0x06, 0x00, 0xB3, 0x05, 0x01, 0x00, 0x00, 0x02,
	0xDE, 0xBF, 0x01, 0x0F, 0xE0, 0xBF, 0x5D, 0x7E, 0x07, 0x00, 0xA3, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};
u8 mbrSt[68] = {
	0x00, 0x00, 0x00, 0x03, 0x18, 0x04, 0x06, 0x0F, 0xE0, 0x3B, 0x77, 0x08,
	0x00, 0x00, 0x89, 0x6F, 0x06, 0x00, 0x00, 0x02, 0xCE, 0x3C, 0x06, 0x0F,
	0xE0, 0xBE, 0x4D, 0x78, 0x06, 0x00, 0xB3, 0x05, 0x01, 0x00, 0x00, 0x02,
	0xDC, 0xBF, 0x01, 0x0F, 0xE0, 0xD5, 0x5B, 0x7E, 0x07, 0x00, 0xA5, 0x2D,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xAA
};

// Volume Boot Records
u8 vbrMain[54] = {
	0xE9, 0x00, 0x00, 0x54, 0x57, 0x4C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x02, 0x20, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0xF8, 0x34, 0x00,
	0x20, 0x00, 0x10, 0x00, 0x77, 0x08, 0x00, 0x00, 0x89, 0x6F, 0x06, 0x00,
	0x00, 0x00, 0x29, 0x78, 0x56, 0x34, 0x12, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20
};
u8 vbrPhoto[54] = {
	0xE9, 0x00, 0x00, 0x54, 0x57, 0x4C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00,
	0x02, 0x20, 0x01, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0xF8, 0x09, 0x00,
	0x20, 0x00, 0x10, 0x00, 0x4D, 0x78, 0x06, 0x00, 0xB3, 0x05, 0x01, 0x00,
	0x01, 0x00, 0x29, 0x78, 0x56, 0x34, 0x12, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20
};

// File tables for /sys/ folder and HWInfo secure
// Why? HWInfo is always at one of 3 set offsets. I use those offsets for HWInfo recovery.
// We will copy over these file tables to ensure the offsets stay the same.

// No idea what this is but I need it lol
u8 fileTable1[16] = {
	0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xFF, 0xFF, 0x00, 0x00
};

// File table for /sys/ folder
u8 fileTable2[64] = {
	0x41, 0x73, 0x00, 0x79, 0x00, 0x73, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x0F,
	0x00, 0x54, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x53, 0x59, 0x53, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x00
};

// File table for HWInfo
u8 fileTable3[192] = {
	0x2E, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x30,
	0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0x75, 0x02,
	0x64, 0x59, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x2E, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x28, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xE5, 0x6C, 0x00, 0x6F, 0x00, 0x67, 0x00, 0x00,
	0x00, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xE5, 0x4F, 0x47, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x00, 0x00, 0x01, 0x00, 0x21, 0x28, 0x64, 0x59, 0x00, 0x00, 0x01, 0x00,
	0x21, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41, 0x48, 0x00, 0x57,
	0x00, 0x49, 0x00, 0x4E, 0x00, 0x46, 0x00, 0x0F, 0x00, 0x9C, 0x4F, 0x00,
	0x5F, 0x00, 0x53, 0x00, 0x2E, 0x00, 0x64, 0x00, 0x61, 0x00, 0x00, 0x00,
	0x74, 0x00, 0x00, 0x00, 0x48, 0x57, 0x49, 0x4E, 0x46, 0x4F, 0x5F, 0x53,
	0x44, 0x41, 0x54, 0x20, 0x00, 0x00, 0x01, 0x00, 0x21, 0x28, 0x64, 0x59,
	0x00, 0x00, 0x50, 0x02, 0x64, 0x59, 0x06, 0x00, 0x00, 0x40, 0x00, 0x00
};

static size_t i;

enum {
	READ_MBR,
	REPAIR_MBR,
	FORMAT_MAIN,
	FORMAT_PHOTO,
	BACK
};

static int _fsMenu(int cursor)
{

    Menu* m = newMenu();
    setMenuHeader(m, "TwlNandTool");
    setListHeader(m, "FileSystem");

	char modeStr[32];
	addMenuItem(m, "Read MBR", NULL, 0, "Test the Master Boot Record.");
	addMenuItem(m, "Repair MBR", NULL, 0, "Repair the Master Boot Record.");
	addMenuItem(m, "Format TWL_MAIN", NULL, 0, "Format the partition where the\n firmware, apps, and saves are\n installed.\n\n THIS WILL ERASE EVERYTHING.");
	addMenuItem(m, "Format TWL_PHOTO", NULL, 0, "Format the partition where\n photos are stored.\n\n THIS WILL ERASE EVERYTHING.");
	addMenuItem(m, "Back", NULL, 0, "Leave the FileSystem menu.");

	m->cursor = cursor;

	//bottom screen
	printMenu(m, 1);

	while (!programEnd)
	{
		swiWaitForVBlank();
		scanKeys();

		if (moveCursor(m))
			printMenu(m, 1);

		if (keysDown() & KEY_A)
			break;
	}

	int result = m->cursor;
	freeMenu(m);

	return result;
}

int fsMain(void)
{

	int cursor = 0;

	while (!programEnd)
	{
		cursor = _fsMenu(cursor);

		switch (cursor)
		{

			case READ_MBR:
				readMbr();
				break;

			case REPAIR_MBR:
				repairMbr();
				break;

			case FORMAT_MAIN:
				formatMain();
				break;

			case FORMAT_PHOTO:
				formatPhoto();
				break;

			case BACK:
				programEnd = true;
				break;
		}
	}

	programEnd = false;

	return 0;
}

int readMbr(void) {
	clearScreen(cSUB);

	nand_ReadSectors(0, 1, sector_buf);
	dsi_crypt_init((const u8*)consoleIDfixed, (const u8*)0x2FFD7BC, is3DS);
	dsi_nand_crypt(sector_buf, sector_buf, 0, SECTOR_SIZE / AES_BLOCK_SIZE);

	iprintf("\n>> MBR (Master Boot Record)     ");
	iprintf("\n--------------------------------");	
    printf("\n     ");
    for (i = 444; i < SECTOR_SIZE; i++) {
        printf("%02X", sector_buf[i]);
        if ((i + 1) % 2 == 0) {
            printf(" ");
        }
        if ((i - 443) % 8 == 0 && i != 444) {
            printf("\n     ");
        }
    }
    if(parse_mbr(sector_buf, is3DS)) {
    	iprintf("\n\n    \x1B[31mERROR!\x1B[30m MBR is corrupted.");
    }

	iprintf("\n\n  Please Push Select To Return  ");

	while (true)
	{
		swiWaitForVBlank();
		scanKeys();

		if (keysDown() & KEY_SELECT )
			break;
	}
}

int repairMbr(void) {
	clearScreen(cSUB);

	iprintf("\n>> Repair Corrupted MBR         ");
	iprintf("\n--------------------------------");	

    if(!parse_mbr(sector_buf, is3DS)) {
		if (choicePrint("NAND does not look corrupt.\nRepair anyway?") == NO) {
			return 0;
		}
	}

    iprintf("\nNAND type : %s (0x%02X)", nandInfo.NAND_PNM, nandInfo.NAND_MID);

    memset(sector_buf, 0, 444);
    if (nandInfo.NAND_MID == 0x15) {
		memcpy(sector_buf + 444, mbrSamsung, sizeof(mbrSamsung));
    } else if (nandInfo.NAND_MID == 0xFE) {
		memcpy(sector_buf + 444, mbrSt, sizeof(mbrSt));
    }

    // Write new MBR, encrypt it, then save it.
    // Afterwards we read it back from NAND and decrypt to confirm it works.
    //
    // No need to do safety checks before writing since corrupted MBR is already broken.
    iprintf("\nWriting new MBR...");

	dsi_nand_crypt(sector_buf, sector_buf, 0, SECTOR_SIZE / AES_BLOCK_SIZE);
	nand_WriteSectors(0, 1, sector_buf);

    iprintf("\nTesting new MBR...");

	nand_ReadSectors(0, 1, sector_buf);
	dsi_nand_crypt(sector_buf, sector_buf, 0, SECTOR_SIZE / AES_BLOCK_SIZE);

    if(parse_mbr(sector_buf, is3DS)) {
    	iprintf("\n\n    \x1B[31mERROR!\x1B[30m Failed to fix MBR.");
    } else {
    	iprintf("\n\x1B[32mThe new MBR passed!\x1B[30m");
    }

	iprintf("\n\n  Please Push Select To Return  ");

	while (true)
	{
		swiWaitForVBlank();
		scanKeys();

		if (keysDown() & KEY_SELECT )
			break;
	}
}

int formatMain(void) {
	clearScreen(cSUB);

	iprintf("\n>> Format TWL_MAIN              ");
	iprintf("\n--------------------------------");

	iprintf("\n\nWriting VBR...");
	memset(file_buf, 0, 0x200);
	// Write the first 54 bytes, then pad to 0x1FE. Finally write 0x55AA
	memcpy(file_buf, vbrMain, sizeof(vbrMain));
    memset(file_buf + sizeof(vbrMain), 0, (BUFFER_SIZE - sizeof(vbrMain) - 2));
    memset(file_buf + SECTOR_SIZE - 2, 0x55, 1);
    memset(file_buf + SECTOR_SIZE - 1, 0xAA, 1);
	good_nandio_write(0x10EE00, 0x200, file_buf, true);
	iprintf("\nClearing file tables...");
	memset(file_buf, 0, 0x600);
	for (i = 0; i < 0x3d8; i++) {
		good_nandio_write(0x10EE00 + 0x200 + (0x600 * i), 0x600, file_buf, true);
	}
	iprintf("\nMaking new file tables...");
	memset(file_buf, 0, 0x200);
	memcpy(file_buf, fileTable1, sizeof(fileTable1));
	good_nandio_write(0x115800, sizeof(fileTable1), file_buf, true);
	memset(file_buf, 0, 0x200);
	memcpy(file_buf, fileTable2, sizeof(fileTable2));
	good_nandio_write(0x11C000, sizeof(fileTable2), file_buf, true);
	memset(file_buf, 0, 0x200);
	memcpy(file_buf, fileTable3, sizeof(fileTable3));
	good_nandio_write(0x120000, sizeof(fileTable3), file_buf, true);

	iprintf("\nAll done!");

	iprintf("\n\n  Please Push Select To Return  ");

	while (true)
	{
		swiWaitForVBlank();
		scanKeys();

		if (keysDown() & KEY_SELECT )
			break;
	}	
}

int formatPhoto(void) {
	clearScreen(cSUB);

	iprintf("\n>> Format TWL_PHOTO             ");
	iprintf("\n--------------------------------");

	iprintf("\n\nWriting VBR...");
	memset(file_buf, 0, 0x200);
	// Write the first 54 bytes, then pad to 0x1FE. Finally write 0x55AA
	memcpy(file_buf, vbrPhoto, sizeof(vbrPhoto));
    memset(file_buf + sizeof(vbrPhoto), 0, (BUFFER_SIZE - sizeof(vbrPhoto) - 2));
    memset(file_buf + SECTOR_SIZE - 2, 0x55, 1);
    memset(file_buf + SECTOR_SIZE - 1, 0xAA, 1);
	good_nandio_write(0xCF09A00, 0x200, file_buf, true);
	iprintf("\nClearing file tables...");
	memset(file_buf, 0, 0x200);
	for (i = 0; i < 0x13A; i++) {
		good_nandio_write(0xCF09A00 + 0x200 + (0x200 * i), 0x200, file_buf, true);
	}

	iprintf("\nAll done!");

	iprintf("\n\n  Please Push Select To Return  ");

	while (true)
	{
		swiWaitForVBlank();
		scanKeys();

		if (keysDown() & KEY_SELECT )
			break;
	}	
}